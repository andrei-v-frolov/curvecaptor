#!/usr/bin/wish

# Curve Captor - vacuum tube curve capture and model builder tool
# 
# Copyright (C) 2001 Andrei Frolov <andrei@phys.ualberta.ca>
# Distributed under the terms of GNU Public License.


# Initialization
set file [lindex $argv 0]
catch {image delete curves}
image create photo curves -file $file
set device [file rootname [file tail $file]]
set backend [file join [file dirname $argv0] tubefit]

wm title . "Curve Captor -- $file"
wm iconname . "valve"


# Curve parameters
set val(Vp) 0; set incr(Vp) 100.0; set units(Vp) "V"
set val(Vg) 0; set incr(Vg)  -2.5; set units(Vg) "V"
set val(Ip) 0; set incr(Ip)  10.0; set units(Ip) "mA"
set val(Ig) 0; set incr(Ig)   1.0; set units(Ig) "mA"

set type 3; set format {Vp Ip Vg}
set param Vg; set axis 0; set markstyle "data(+)"

# Step parameter value
proc step {p} {
	global val incr
	
	set val($p) [expr $val($p)+$incr($p)]
}

# Return current curve parameter tag
proc ctag {} {
	global param val axis
	
	set t "$param=$val($param)"
	if $axis then { step $param }
	return $t
}

# Draw current curve mark
proc draw {c x y s} {
	switch $s {
		"tick(v)" {
			$c create polygon\
				$x $y\
				[expr $x-4] [expr $y-13]\
				[expr $x+5] [expr $y-13]\
				$x $y\
				[expr $x-6] $y\
				[expr $x+7] $y\
			-width 1 -outline red
		}
		"tick(^)" {
			$c create polygon\
				$x $y\
				[expr $x-4] [expr $y+13]\
				[expr $x+5] [expr $y+13]\
				$x $y\
				[expr $x-6] $y\
				[expr $x+7] $y\
			-width 1 -outline red
		}
		"tick(<)" {
			$c create polygon\
				$x $y\
				[expr $x+13] [expr $y-4]\
				[expr $x+13] [expr $y+5]\
				$x $y\
				$x [expr $y-6]\
				$x [expr $y+7]\
			-width 1 -outline red
		}
		"tick(>)" {
			$c create polygon\
				$x $y\
				[expr $x-13] [expr $y-4]\
				[expr $x-13] [expr $y+5]\
				$x $y\
				$x [expr $y-6]\
				$x [expr $y+7]\
			-width 1 -outline red
		}
		default {
			$c create line\
				$x $y $x [expr $y+7]\
				$x $y [expr $x+7] $y\
				$x $y $x [expr $y-6]\
				$x $y [expr $x-6] $y\
			-width 1
		}
	}
}


# Toolbar
set t .tools
frame $t -borderwidth 3 -relief raised

label $t.active -foreground red
label $t.plabel; label $t.units; label $t.at -text "@";
entry $t.label -textvariable device -width 6 -justify left -font {courier 18 bold}
entry $t.param -width 6 -justify left; entry $t.pincr -width 6 -justify right
button $t.incr -text "increment" -command { step $param } -padx 0 -pady 0 -relief flat

# Setup curve to be traced
proc tracing {f p a} {
	global t format param axis units
	
	set format $f; set param $p; set axis $a;
	
	$t.plabel configure -text "    $p ="
	$t.param configure -textvariable val($p)
	$t.pincr configure -textvariable incr($p)
	$t.units configure -text "\[$units($p)\]"
}

set m $t.curve.menu
menubutton $t.curve -menu $m -textvariable curve -width 13 -direction below -indicatoron yes -borderwidth 2 -relief sunk
menu $m -tearoff 0

$m add cascade -menu $m.type -label "Vacuum tube type"
$m add separator
$m add command -label "Plate Characteristics: Vp axis" -command {
	set curve "Vp axis"; set markstyle "tick(v)"; tracing {Vp Ip Vg} Vp 1
}
$m add command -label "Plate Characteristics: Ip axis" -command {
	set curve "Ip axis"; set markstyle "tick(<)"; tracing {Vp Ip Vg} Ip 1
}
$m add command -label "Plate Characteristics Curve" -command {
	set curve "Plate curve"; set markstyle "data(+)"; tracing {Vp Ip Vg} Vg 0
}
$m add separator
$m add command -label "Grid Characteristics: Vp axis" -command {
	set curve "Vp axis"; set markstyle "tick(v)"; tracing {Vp Ig Vg} Vp 1
}
$m add command -label "Grid Characteristics: Ig axis" -command {
	set curve "Ig axis"; set markstyle "tick(<)"; tracing {Vp Ig Vg} Ig 1
}
$m add command -label "Grid Characteristics Curve" -command {
	set curve "Grid curve"; set markstyle "data(+)"; tracing {Vp Ig Vg} Vg 0
}
$m add separator
$m add command -label "Transfer Characteristics: Vg axis" -command {
	set curve "Vg axis"; set markstyle "tick(v)"; tracing {Vg Ip Vp} Vg 1
}
$m add command -label "Transfer Characteristics: Ip axis" -command {
	set curve "Ip axis"; set markstyle "tick(<)"; tracing {Vg Ip Vp} Ip 1
}
$m add command -label "Transfer Characteristics Curve" -command {
	set curve "Transfer curve"; set markstyle "data(+)"; tracing {Vg Ip Vp} Vp 0
}
$m invoke 2

menu $m.type -tearoff 0
$m.type add radiobutton -label "Diode" -variable type -value 2 -command {
	foreach i {2 3 4 6 7 8 10 11 12} { $m entryconfigure $i -state normal }
	foreach i {6 7 8 10 11 12} { $m entryconfigure $i -state disabled }
}
$m.type add radiobutton -label "Triode" -variable type -value 3 -command {
	foreach i {2 3 4 6 7 8 10 11 12} { $m entryconfigure $i -state normal }
}
$m.type invoke 1


pack $t.label $t.curve $t.plabel $t.param $t.at $t.pincr $t.units $t.incr -side left -expand no -pady 4
pack $t.active -side right -expand no -pady 4
pack $t -side top -fill x


# Curve tracer canvas
set c .canvas
canvas $c -width [image width curves] -height [image height curves]
$c create image 0 0 -anchor nw -image curves
pack $c -side top -padx .5m -pady .5m

bind $c <1>		{mark $c [ctag] %x %y $markstyle}
bind $c <B1-Motion>	{move $c %x %y}

$c bind X <2>		{select $c %x %y}
$c bind X <B2-Motion>	{move $c %x %y}

bind . <Left>		{nudge $c -1 0}
bind . <Right>		{nudge $c 1 0}
bind . <Up>		{nudge $c 0 -1}
bind . <Down>		{nudge $c 0 1}
bind . <KP_Left>	{nudge $c -1 0}
bind . <KP_Right>	{nudge $c 1 0}
bind . <KP_Up>		{nudge $c 0 -1}
bind . <KP_Down>	{nudge $c 0 1}
bind . <KP_Home>	{nudge $c -1 -1}
bind . <KP_Page_Up>	{nudge $c 1 -1}
bind . <KP_End>		{nudge $c -1 1}
bind . <KP_Page_Down>	{nudge $c 1 1}

# Activate tag
proc activate {c t} {
	$c itemconf active -fill red; $c dtag active
	$c addtag active withtag $t; $c itemconf active -fill orange
	$c raise active
	
	.tools.active configure -text "Active marker: [lindex [$c gettags $t] 0] "
}

# New cross-hairs mark
proc mark {c m x y s} {
	global X Y; set X $x; set Y $y
	
	set t [draw $c $x $y $s]
	$c addtag $m withtag $t
	$c addtag $s withtag $t
	$c addtag X withtag $t
	activate $c $t
}

# Select mark for moving
proc select {c x y} {
	global X Y; set X $x; set Y $y
	
	activate $c current
}

# Move active mark
proc move {c x y} {
	global X Y; nudge $c [expr $x-$X] [expr $y-$Y]; set X $x; set Y $y
}

# Nudge active mark
proc nudge {c dx dy} {
	if {[$c find withtag active] == ""} {
		return
	}
	
	$c move active $dx $dy
}


# Return current markers as a list
proc markers {c} {
	set ml {}
	
	foreach t [$c find withtag X] {
		lappend ml [concat [lindex [$c gettags $t] 0] [lrange [$c coords $t] 0 1] [lindex [$c gettags $t] 1] ]
	}
	
	return $ml
}

# Send tagged curve data to a channel
proc dump {fp c} {
	foreach t [markers $c] {
		puts $fp $t
	}
}

# Read tagged curve data from a channel
proc slurp {fp c} {
	foreach t [split [read -nonewline $fp] "\n"] {
		if {[string match "#*" $t]} { continue }
		
		set l [split $t]; mark $c [lindex $l 0] [lindex $l 1] [lindex $l 2] [lindex $l 3]
	}
}

# Save tagged curve data to a file
proc save_markers {c} {
	global device
	
	set f [tk_getSaveFile -initialfile "$device.crv"]
	if {[string length $f] == 0} { return }
	
	set fp [open $f w]; dump $fp $c; close $fp
}

# Load tagged curve data from a file
proc load_markers {c} {
	global device
	
	set f [tk_getOpenFile -initialfile "$device.crv"]
	if {[string length $f] == 0} { return }
	
	set fp [open $f r]; slurp $fp $c; close $fp
}


set b .buttons; frame $b
button $b.load -text "Load Markers" -command {load_markers $c}
button $b.save -text "Save Markers" -command {save_markers $c}
button $b.capture -text "Capture Curve" -command {capture_data $c}
button $b.dismiss -text Dismiss -command {destroy .}
pack $b.load $b.save $b.capture $b.dismiss -side left -expand 1
pack $b -side bottom -fill x -pady 2m



# Open curve data window
proc curve_data {c} {
	global backend type format
	
	set m [markers $c]; if {[llength $m] < 1} { return "" }
	return [exec -keepnewline $backend -$type -f"$format" -d << [join $m "\n"] 2>@ stderr]
}

# Save curve data to a file
proc save_data {t} {
	global device
	
	set f [tk_getSaveFile -initialfile "$device.dat"]
	if {[string length $f] == 0} { return }
	
	set fp [open $f w]; puts -nonewline $fp [$t get 0.0 end]; close $fp
}

# Load curve data from a file
proc load_data {t} {
	global device
	
	set f [tk_getOpenFile -initialfile "$device.dat"]
	if {[string length $f] == 0} { return }
	
	set fp [open $f r]; $t insert end [read -nonewline $fp]; close $fp
}

# Capture curve and open data window
proc capture_data {c} {
	global device
	
	set w .data
	catch {destroy $w}
	toplevel $w
	
	wm title $w "Curve Captor -- $device curve data"
	wm iconname $w "valve"
	
	set t $w.text; set s $w.scroll
	scrollbar $s -command "$t yview"
	text $t -relief sunken -bd 2 -yscrollcommand "$s set" -setgrid 1 -width 64 -height 64
	
	$t insert 0.0 [curve_data $c]
	$t mark set insert 0.0
	
	set b $w.buttons; frame $b
	button $b.load -text "Load Data" -command "load_data $t"
	button $b.save -text "Save Data" -command "save_data $t"
	button $b.model -text "Build Model" -command "model $t"
	button $b.dismiss -text Dismiss -command "destroy $w"
	pack $b.load $b.save $b.model $b.dismiss -side left -expand 1
	
	pack $b -side bottom -fill x -pady 2m
	pack $s -side right -fill y
	pack $t -expand yes -fill both
}



# Print canvas as a Postscript file
proc print {c} {
	set f [tk_getSaveFile -initialfile "|lpr"]
	if {[string length $f] == 0} { return }
	if {[set p [string first "|" $f]] != -1} {
		set f [string range $f $p end]
	}
	
	set fp [open $f w]; puts $fp [$c postscript -rotate 1]; close $fp
}

# Render curves plot on a canvas
proc render {c t} {
	global Pa I0 V0 RL Vin Vout wave signal
	global backend device type macro mparams
	
	# Backend options
	set b {$backend -$type -M "$macro\($mparams\)"}
	if {$Pa > 0} { append b { -P$Pa} }
	if {($V0 > 0) && ($I0 > 0)} {
		append b { -L$V0,$I0}
		if {$RL > 0} { append b {,$RL} }
	}
	if {($signal == "input") && ($Vin > 0)} { append b { -I$Vin} }
	if {($signal == "output") && ($Vout > 0)} { append b { -O$Vout} }
	if {$wave} { append b { -w} }
	append b { -p << [$t get 0.0 end] 2>@ stderr}
	
	# Run backend
	set p [eval "exec $b"]; $c delete all; foreach i [split $p "\n"] { eval "$c create $i" }
	$c create text 675 26 -anchor e -font {courier 18 bold} -text "$device" -fill black
	
	update
}

# Build models and inspect the fit
proc model {t} {
	global backend device type macro mparams
	
	set w .model
	catch {destroy $w}
	toplevel $w
	
	wm title $w "Curve Captor -- $device model"
	wm iconname $w "valve"
	
	
	# Operation parameters
	set f $w.pframe
	frame $f -borderwidth 3 -relief raised
	label $f.l1 -text "Rated power: "
	label $f.l2 -text "W    Working point: "
	label $f.l3 -text "V, "
	label $f.l4 -text "mA; load "
	label $f.l5 -text "R"
	label $f.l6 -text "V"
	
	entry $f.pa -width 4 -justify right -textvariable Pa
	entry $f.v0 -width 6 -justify right -textvariable V0
	entry $f.i0 -width 6 -justify right -textvariable I0
	entry $f.rl -width 6 -justify right -textvariable RL
	checkbutton $f.wave -variable wave -text "AC signal"
	entry $f.vac -width 6 -justify right
	
	set m $f.sig.menu
	menubutton $f.sig -menu $m -textvariable signal -width 5 -direction below -indicatoron no -borderwidth 0 -relief sunk
	menu $m -tearoff 0
	$m add command -label "input" -command "set signal input; $f.vac configure -textvariable Vin"
	$m add command -label "output" -command "set signal output; $f.vac configure -textvariable Vout"
	$m invoke 0
	
	pack $f.l1 $f.pa $f.l2 $f.v0 $f.l3 $f.i0 $f.l4 $f.rl $f.l5 -side left -expand no -pady 4
	pack $f.l6 $f.vac $f.sig $f.wave -side right -expand no -pady 4
	pack $f -side top -fill x
	
	
	# Plot canvas
	set c $w.canvas
	canvas $c -width 720 -height 576 -background white
	$c create text 360 288 -anchor c -text "Fitting model parameters; please wait..." -fill black
	pack $c -side top -padx .5m -pady .5m; update
	
	
	# Model selector
	set f $w.mframe; set m $f.macro.menu
	frame $f -borderwidth 3 -relief raised
	menubutton $f.macro -menu $m -textvariable macro -width 7 -direction above -indicatoron yes -borderwidth 2 -relief sunk
	entry $f.param -width 84 -justify left -textvariable mparams
	
	menu $m -tearoff 0
	set p [exec $backend -v -$type -m << [$t get 0.0 end] 2>@ stderr]
	foreach i [split $p "\n"] { eval "$m $i" }
	
	pack $f.macro $f.param -side left -expand 1 -pady 4
	pack $f -side top -fill x
	
	
	# Action buttons
	set b $w.buttons; frame $b
	button $b.plot -text Redraw -command "render $c $t"
	button $b.print -text Print -command "print $c"
	button $b.code -text "See Spice Code" -command "spice_code"
	button $b.dismiss -text Dismiss -command "destroy $w"
	pack $b.plot $b.print $b.code $b.dismiss -side left -expand 1
	pack $b -side bottom -fill x -pady 2m
	
	render $c $t
}



# Run text through m4 preprocessor
proc m4 {h t} {
	global argv0
	
	set f [file join [file dirname $argv0] "$h.m4"]
	set fp [open $f r]; set ht [read $fp]; append ht $t; close $fp
	
	return [exec m4 << $ht 2>@ stderr]
}

# Inspect Spice code
proc spice_code {} {
	global device type macro mparams
	
	set w .model.code
	catch {destroy $w}
	toplevel $w
	
	wm title $w "Curve Captor -- $device Spice code"
	wm iconname $w "valve"
	
	
	set m "* $device macro model\n"
	append m ".subckt $device  "
	append m [lindex {{} {} {P K} {P G K}} $type]
	append m "\n    $macro\($mparams\)\n.ends $device\n"
	
	
	set t $w.text; set s $w.scroll
	scrollbar $s -command "$t yview"
	text $t -relief sunken -bd 2 -yscrollcommand "$s set" -setgrid 1 -width 120 -height 15
	
	$t insert 0.0 $m
	$t insert end "\n\n[m4 models $m]"
	$t mark set insert 0.0
	
	set b $w.buttons; frame $b
	button $b.dismiss -text Dismiss -command "destroy $w"
	pack $b.dismiss -side left -expand 1
	
	pack $b -side bottom -fill x -pady 2m
	pack $s -side right -fill y
	pack $t -expand yes -fill both
}
