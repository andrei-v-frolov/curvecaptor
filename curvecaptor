#!/usr/bin/wish
# $Id: curvecaptor,v 1.14 2005/05/11 04:49:15 afrolov Exp $

# Curve Captor - vacuum tube curve capture and model builder tool
# 
# Copyright (C) 2001-2005 Andrei Frolov <frolov@cita.utoronto.ca>
# Distributed under the terms of GNU Public License.
# 
# Uses notebook widget by D. Richard Hipp <drh@acm.org>


########################################################################
# A Notebook widget for Tcl/Tk
# $Revision: 1.14 $
#
# Copyright (C) 1996,1997,1998 D. Richard Hipp
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA  02111-1307, USA.
#
# Author contact information:
#   drh@acm.org
#   http://www.hwaci.com/drh/


#
# Create a new notebook widget
#
proc Notebook:create {w args} {
  global Notebook
  set Notebook($w,label) ""
  set Notebook($w,width) 400
  set Notebook($w,height) 300
  set Notebook($w,pages) {}
  set Notebook($w,top) 0
  set Notebook($w,pad) 5
  set Notebook($w,fg,on) black
  set Notebook($w,fg,off) grey50
  canvas $w -bd 0 -highlightthickness 0 -takefocus 0
  set Notebook($w,bg) [$w cget -bg]
  bind $w <1> "Notebook:click $w %x %y"
  bind $w <Configure> "Notebook:scheduleExpand $w"
  eval Notebook:config $w $args
}

#
# Change configuration options for the notebook widget
#
proc Notebook:config {w args} {
  global Notebook
  foreach {tag value} $args {
    switch -- $tag {
      -label {
        set Notebook($w,label) $value
      }
      -width {
        set Notebook($w,width) $value
      }
      -height {
        set Notebook($w,height) $value
      }
      -pages {
        set Notebook($w,pages) $value
      }
      -pad {
        set Notebook($w,pad) $value
      }
      -bg {
        set Notebook($w,bg) $value
      }
      -fg {
        set Notebook($w,fg,on) $value
      }
      -disabledforeground {
        set Notebook($w,fg,off) $value
      }
    }
  }

  #
  # After getting new configuration values, reconstruct the widget
  #
  $w delete all
  set Notebook($w,x1) $Notebook($w,pad)
  set Notebook($w,x2) [expr $Notebook($w,x1)+2]
  set Notebook($w,x3) [expr $Notebook($w,x2)+$Notebook($w,width)]
  set Notebook($w,x4) [expr $Notebook($w,x3)+2]
  set Notebook($w,y1) [expr $Notebook($w,pad)+2]
  set Notebook($w,y2) [expr $Notebook($w,y1)+2]
  set Notebook($w,y5) [expr $Notebook($w,y1)+30]
  set Notebook($w,y6) [expr $Notebook($w,y5)+2]
  set Notebook($w,y3) [expr $Notebook($w,y6)+$Notebook($w,height)]
  set Notebook($w,y4) [expr $Notebook($w,y3)+2]
  set x $Notebook($w,x1)
  set cnt 0
  set y7 [expr $Notebook($w,y1)+10]
  $w create text $Notebook($w,width) $Notebook($w,y2) \
     -anchor ne -font {courier 24 bold} -text $Notebook($w,label)
  foreach p $Notebook($w,pages) {
    set Notebook($w,p$cnt,x5) $x
    set id [$w create text 0 0 -text $p -anchor nw -tags "p$cnt t$cnt"]
    set bbox [$w bbox $id]
    set width [lindex $bbox 2]
    $w move $id [expr $x+10] $y7
    $w create line \
       $x $Notebook($w,y5)\
       $x $Notebook($w,y2) \
       [expr $x+2] $Notebook($w,y1) \
       [expr $x+$width+16] $Notebook($w,y1) \
       -width 2 -fill white -tags p$cnt
    $w create line \
       [expr $x+$width+16] $Notebook($w,y1) \
       [expr $x+$width+18] $Notebook($w,y2) \
       [expr $x+$width+18] $Notebook($w,y5) \
       -width 2 -fill black -tags p$cnt
    set x [expr $x+$width+20]
    set Notebook($w,p$cnt,x6) [expr $x-2]
    if {![winfo exists $w.f$cnt]} {
      frame $w.f$cnt -bd 0
    }
    $w.f$cnt config -bg $Notebook($w,bg)
    place $w.f$cnt -x $Notebook($w,x2) -y $Notebook($w,y6) \
      -width $Notebook($w,width) -height $Notebook($w,height)
    incr cnt
  }
  $w create line \
     $Notebook($w,x1) [expr $Notebook($w,y5)-2] \
     $Notebook($w,x1) $Notebook($w,y3) \
     -width 2 -fill white
  $w create line \
     $Notebook($w,x1) $Notebook($w,y3) \
     $Notebook($w,x2) $Notebook($w,y4) \
     $Notebook($w,x3) $Notebook($w,y4) \
     $Notebook($w,x4) $Notebook($w,y3) \
     $Notebook($w,x4) $Notebook($w,y6) \
     $Notebook($w,x3) $Notebook($w,y5) \
     -width 2 -fill black
  $w config -width [expr $Notebook($w,x4)+$Notebook($w,pad)] \
            -height [expr $Notebook($w,y4)+$Notebook($w,pad)] \
            -bg $Notebook($w,bg)
  set top $Notebook($w,top)
  set Notebook($w,top) -1
  Notebook:raise.page $w $top
}

#
# This routine is called whenever the mouse-button is pressed over
# the notebook.  It determines if any page should be raised and raises
# that page.
#
proc Notebook:click {w x y} {
  global Notebook
  if {$y<$Notebook($w,y1) || $y>$Notebook($w,y6)} return
  set N [llength $Notebook($w,pages)]
  for {set i 0} {$i<$N} {incr i} {
    if {$x>=$Notebook($w,p$i,x5) && $x<=$Notebook($w,p$i,x6)} {
      Notebook:raise.page $w $i
      break
    }
  }
}

#
# For internal use only.  This procedure raised the n-th page of
# the notebook
#
proc Notebook:raise.page {w n} {
  global Notebook
  if {$n<0 || $n>=[llength $Notebook($w,pages)]} return
  set top $Notebook($w,top)
  if {$top>=0 && $top<[llength $Notebook($w,pages)]} {
    $w move p$top 0 2
  }
  $w move p$n 0 -2
  $w delete topline
  if {$n>0} {
    $w create line \
       $Notebook($w,x1) $Notebook($w,y6) \
       $Notebook($w,x2) $Notebook($w,y5) \
       $Notebook($w,p$n,x5) $Notebook($w,y5) \
       $Notebook($w,p$n,x5) [expr $Notebook($w,y5)-2] \
       -width 2 -fill white -tags topline
  }
  $w create line \
    $Notebook($w,p$n,x6) [expr $Notebook($w,y5)-2] \
    $Notebook($w,p$n,x6) $Notebook($w,y5) \
    -width 2 -fill white -tags topline
  $w create line \
    $Notebook($w,p$n,x6) $Notebook($w,y5) \
    $Notebook($w,x3) $Notebook($w,y5) \
    -width 2 -fill white -tags topline
  set Notebook($w,top) $n
  raise $w.f$n
}

#
# Change the page-specific configuration options for the notebook
#
proc Notebook:pageconfig {w name args} {
  global Notebook
  set i [lsearch $Notebook($w,pages) $name]
  if {$i<0} return
  foreach {tag value} $args {
    switch -- $tag {
      -state {
        if {"$value"=="disabled"} {
          $w itemconfig t$i -fg $Notebook($w,fg,off)
        } else {
          $w itemconfig t$i -fg $Notebook($w,fg,on)
        }
      }
      -onexit {
        set Notebook($w,p$i,onexit) $value
      }
    }
  }
}

#
# This procedure raises a notebook page given its name.  But first
# we check the "onexit" procedure for the current page (if any) and
# if it returns false, we don't allow the raise to proceed.
#
proc Notebook:raise {w name} {
  global Notebook
  set i [lsearch $Notebook($w,pages) $name]
  if {$i<0} return
  if {[info exists Notebook($w,p$i,onexit)]} {
    set onexit $Notebook($w,p$i,onexit)
    if {"$onexit"!="" && [eval uplevel #0 $onexit]!=0} {
      Notebook:raise.page $w $i
    }
  } else {
    Notebook:raise.page $w $i
  }
}

#
# Return the frame associated with a given page of the notebook.
#
proc Notebook:frame {w name} {
  global Notebook
  set i [lsearch $Notebook($w,pages) $name]
  if {$i>=0} {
    return $w.f$i
  } else {
    return {}
  }
}

#
# Try to resize the notebook to the next time we become idle.
#
proc Notebook:scheduleExpand w {
  global Notebook
  if {[info exists Notebook($w,expand)]} return
  set Notebook($w,expand) 1
  after idle "Notebook:expand $w"
}

#
# Resize the notebook to fit inside its containing widget.
#
proc Notebook:expand w {
  global Notebook
  set wi [expr [winfo width $w]-($Notebook($w,pad)*2+4)]
  set hi [expr [winfo height $w]-($Notebook($w,pad)*2+36)]
  Notebook:config $w -width $wi -height $hi
  catch {unset Notebook($w,expand)}
}

########################################################################
# notebook widget library code ends here
########################################################################



########################################################################
# curvecaptor code begins here
########################################################################

# Initialization
set backend [file join [file dirname $argv0] tubefit]

# Notebook layout
Notebook:create .n -pages {"Curve Tracer" "Device Data" "Device Model" "Spice Code"} -width 720 -height 696 -pad 2 

set wt [Notebook:frame .n "Curve Tracer"]
set wd [Notebook:frame .n "Device Data"]
set wm [Notebook:frame .n "Device Model"]
set ws [Notebook:frame .n "Spice Code"]

pack .n -fill both -expand 1

# Set device name and labels
proc set_device {dev} {
	global device
	
	set device $dev; Notebook:config .n -label $device
	wm title . "Curve Captor[expr {$device != "" ? " -- $device" : ""}]"
}

set_device {}



#################### Curve Tracer ######################################

# Curve parameters
set val(Vp) 0; set incr(Vp) 100.0; set units(Vp) "V"
set val(Vg) 0; set incr(Vg)  -2.5; set units(Vg) "V"
set val(Ip) 0; set incr(Ip)  10.0; set units(Ip) "mA"
set val(Ig) 0; set incr(Ig)   1.0; set units(Ig) "mA"

set type 3; set format {Vp Ip Vg}
set param Vg; set axis 0; set markstyle "data(+)"


# Step parameter value
proc step {p} {
	global val incr
	
	set val($p) [expr $val($p)+$incr($p)]
}

# Return current curve parameter tag
proc ctag {} {
	global param val axis
	
	set t "$param=$val($param)"
	if $axis then { step $param }
	return $t
}

# Draw current curve mark
proc draw {c x y s} {
	switch $s {
		"tick(v)" {
			$c create polygon\
				$x $y\
				[expr $x-4] [expr $y-13]\
				[expr $x+5] [expr $y-13]\
				$x $y\
				[expr $x-6] $y\
				[expr $x+7] $y\
			-width 1 -outline red
		}
		"tick(^)" {
			$c create polygon\
				$x $y\
				[expr $x-4] [expr $y+13]\
				[expr $x+5] [expr $y+13]\
				$x $y\
				[expr $x-6] $y\
				[expr $x+7] $y\
			-width 1 -outline red
		}
		"tick(<)" {
			$c create polygon\
				$x $y\
				[expr $x+13] [expr $y-4]\
				[expr $x+13] [expr $y+5]\
				$x $y\
				$x [expr $y-6]\
				$x [expr $y+7]\
			-width 1 -outline red
		}
		"tick(>)" {
			$c create polygon\
				$x $y\
				[expr $x-13] [expr $y-4]\
				[expr $x-13] [expr $y+5]\
				$x $y\
				$x [expr $y-6]\
				$x [expr $y+7]\
			-width 1 -outline red
		}
		default {
			$c create line\
				$x $y $x [expr $y+7]\
				$x $y [expr $x+7] $y\
				$x $y $x [expr $y-6]\
				$x $y [expr $x-6] $y\
			-width 1
		}
	}
}


# Toolbar
set t $wt.tools; frame $t -borderwidth 1 -relief flat

label $t.active -foreground red
label $t.plabel; label $t.units; label $t.at -text "@";
entry $t.param -width 6 -justify left; entry $t.pincr -width 6 -justify right
button $t.incr -text "increment" -command { step $param } -padx 0 -pady 0 -relief flat

# Setup curve to be traced
proc tracing {f p a} {
	global wt format param axis units
	
	set format $f; set param $p; set axis $a; set t $wt.tools
	
	$t.plabel configure -text "    $p ="
	$t.param configure -textvariable val($p)
	$t.pincr configure -textvariable incr($p)
	$t.units configure -text "\[$units($p)\]"
}

set mt $t.type.menu; set mc $t.curve.menu
menubutton $t.type -menu $mt -textvariable stype -width 6 -direction below -indicatoron yes -borderwidth 2 -relief sunk
menubutton $t.curve -menu $mc -textvariable curve -width 13 -direction below -indicatoron yes -borderwidth 2 -relief sunk
menu $mt -tearoff 0; menu $mc -tearoff 0

$mt add command -label "diode" -command {
	set type 2; set stype diode 
	
	foreach i {0 1 2} { $mc entryconfigure $i -state normal }
	foreach i {4 5 6} { $mc entryconfigure $i -state disabled }
}
$mt add command -label "triode" -command {
	set type 3; set stype triode 
	
	foreach i {0 1 2 4 5 6} { $mc entryconfigure $i -state normal }
}


$mc add command -label "Plate Characteristics: Vp axis" -command {
	set curve "Vp axis"; set markstyle "tick(v)"; tracing {Vp Ip Vg} Vp 1
}
$mc add command -label "Plate Characteristics: Ip axis" -command {
	set curve "Ip axis"; set markstyle "tick(<)"; tracing {Vp Ip Vg} Ip 1
}
$mc add command -label "Plate Characteristics Curve" -command {
	set curve "Plate curve"; set markstyle "data(+)"; tracing {Vp Ip Vg} Vg 0
}
$mc add separator
$mc add command -label "Transfer Characteristics: Vg axis" -command {
	set curve "Vg axis"; set markstyle "tick(v)"; tracing {Vg Ip Vp} Vg 1
}
$mc add command -label "Transfer Characteristics: Ip axis" -command {
	set curve "Ip axis"; set markstyle "tick(<)"; tracing {Vg Ip Vp} Ip 1
}
$mc add command -label "Transfer Characteristics Curve" -command {
	set curve "Transfer curve"; set markstyle "data(+)"; tracing {Vg Ip Vp} Vp 0
}


$mt invoke 1; $mc invoke 0


pack $t.type $t.curve $t.plabel $t.param $t.at $t.pincr $t.units $t.incr -side left -expand no -pady 4
pack $t.active -side right -expand no -pady 4
pack $t -side top -fill x


# Curve tracer canvas
set ct $wt.canvas
canvas $ct -width 720 -height 612 -background white -borderwidth 2 -relief groove
pack $ct -side top -padx .5m -pady .5m

bind $ct <1>		{mark $ct [ctag] [$ct canvasx %x] [$ct canvasy %y] $markstyle}
bind $ct <B1-Motion>	{move $ct [$ct canvasx %x] [$ct canvasy %y]}

$ct bind X <2>		{select $ct [$ct canvasx %x] [$ct canvasy %y]}
$ct bind X <B2-Motion>	{move $ct [$ct canvasx %x] [$ct canvasy %y]}

bind $ct <3>		"$ct scan mark %x %y"
bind $ct <B3-Motion>	"$ct scan dragto %x %y 1"

bind . <Left>		"nudge $ct -1  0"
bind . <Right>		"nudge $ct 1  0"
bind . <Up>		"nudge $ct  0 -1"
bind . <Down>		"nudge $ct  0  1"
bind . <KP_Left>	"nudge $ct -1  0"
bind . <KP_Right>	"nudge $ct  1  0"
bind . <KP_Up>		"nudge $ct  0 -1"
bind . <KP_Down>	"nudge $ct  0  1"
bind . <KP_Home>	"nudge $ct -1 -1"
bind . <KP_Page_Up>	"nudge $ct  1 -1"
bind . <KP_End>		"nudge $ct -1  1"
bind . <KP_Page_Down>	"nudge $ct  1  1"

# Activate tag
proc activate {c t} {
	global wt
	
	$c itemconf active -fill red; $c dtag active
	$c addtag active withtag $t; $c itemconf active -fill orange
	$c raise active
	
	$wt.tools.active configure -text "Active marker: [lindex [$c gettags $t] 0] "
}

# New cross-hairs mark
proc mark {c m x y s} {
	global X Y; set X $x; set Y $y
	
	set t [draw $c $x $y $s]
	$c addtag $m withtag $t
	$c addtag $s withtag $t
	$c addtag X withtag $t
	activate $c $t
}

# Select mark for moving
proc select {c x y} {
	global X Y; set X $x; set Y $y
	
	activate $c current
}

# Move active mark
proc move {c x y} {
	global X Y; nudge $c [expr $x-$X] [expr $y-$Y]; set X $x; set Y $y
}

# Nudge active mark
proc nudge {c dx dy} {
	if {[$c find withtag active] == ""} { return }
	
	$c move active $dx $dy
}


# Return current markers as a list
proc markers {c} {
	set ml {}
	
	foreach t [$c find withtag X] {
		lappend ml [concat [lindex [$c gettags $t] 0] [lrange [$c coords $t] 0 1] [lindex [$c gettags $t] 1] ]
	}
	
	return $ml
}

# Send tagged curve data to a channel
proc dump {fp c} {
	foreach t [markers $c] {
		puts $fp $t
	}
}

# Read tagged curve data from a channel
proc slurp {fp c} {
	foreach t [split [read -nonewline $fp] "\n"] {
		if {[string match "#*" $t]} { continue }
		
		set l [split $t]; mark $c [lindex $l 0] [lindex $l 1] [lindex $l 2] [lindex $l 3]
	}
}

# Save tagged curve data to a file
proc save_markers {c} {
	global device
	
	set f [tk_getSaveFile -initialfile "$device" -defaultextension ".crv"]; if {$f == ""} { return }
	
	catch {
		set fp [open $f w]
		set_device [file rootname [file tail $f]]
		dump $fp $c; close $fp
	}
}

# Load tagged curve data from a file stream
proc load_markers {c fp} { slurp $fp $c }

# Load curve image into tracer
proc load_image {c img} {
	$c delete all; $c create image 0 0 -anchor nw -image $img
	
	$c scan mark 0 0; $c scan dragto \
		[expr ([$c cget -width]-[image width curves])/2] \
		[expr ([$c cget -height]-[image height curves])/2] 1
}


set b $wt.buttons; frame $b
button $b.load -text "Load Markers" -command "load_file {} .crv"
button $b.save -text "Save Markers" -command "save_markers $ct"
button $b.capture -text "Capture Curve >>" -command {
	Notebook:raise .n "Device Data"
	capture_data $wt.canvas $wd.text
}
button $b.dismiss -text Dismiss -command "destroy ."
pack $b.load $b.save $b.capture $b.dismiss -side left -expand 1
pack $b -side bottom -fill x -pady 2m



#################### Device Data #######################################

# Open curve data window
proc curve_data {c} {
	global backend type format
	
	set m [markers $c]; if {[llength $m] < 1} { return "" }
	return [exec -keepnewline $backend -$type -f"$format" -d << [join $m "\n"] 2>@ stderr]
}

# Save curve data to a file
proc save_data {t} {
	global device
	
	set f [tk_getSaveFile -initialfile "$device" -defaultextension ".dat"]; if {$f == ""} { return }
	
	catch {
		set fp [open $f w]
		set_device [file rootname [file tail $f]]
		puts -nonewline $fp [$t get 0.0 end]; close $fp
	}
}

# Load curve data from a file stream
proc load_data {t fp} { $t insert end [read -nonewline $fp] }

# Capture curve and open data window
proc capture_data {c t} {
	$t insert 0.0 [curve_data $c]
	$t mark set insert 0.0
}


set t $wd.text; set s $wd.scroll
scrollbar $s -command "$t yview" -bd 1
text $t -bg white -relief groove -bd 2 -yscrollcommand "$s set" -setgrid 1 -width 100 -height 50

set b $wd.buttons; frame $b
button $b.load -text "Load Data" -command "load_file {} .dat"
button $b.save -text "Save Data" -command "save_data $t"
button $b.model -text "Build Model >>" -command {
	Notebook:raise .n "Device Model"
	model $wd.text
}
button $b.dismiss -text Dismiss -command "destroy ."
pack $b.load $b.save $b.model $b.dismiss -side left -expand 1

pack $b -side bottom -fill x -pady 2m
pack $s -side right -fill y
pack $t -expand yes -fill both



#################### Device Model ######################################

# Print canvas as a Postscript file
proc print {c} {
	set f [tk_getSaveFile -initialfile "|lpr"]; if {$f == ""} { return }
	
	if {[set p [string first "|" $f]] != -1} {
		set f [string range $f $p end]
	}
	
	set fp [open $f w]; puts $fp [$c postscript -rotate 1]; close $fp
}

# Render curves plot on a canvas
proc render {c t} {
	global Pa I0 V0 RL Vin Vout wave signal
	global backend device type macro mparams circuit
	
	# Backend options
	set b {$backend -$type -M "$macro\($mparams\)"}
	if {$Pa > 0} { append b { -P$Pa} }
	if {($V0 > 0) && ($I0 > 0)} {
		append b { -L$V0,$I0}
		if {$RL > 0} { append b {,$RL} }
	}
	if {($signal == "input") && ($Vin > 0)} { append b { -I$Vin} }
	if {($signal == "output") && ($Vout > 0)} { append b { -O$Vout} }
	if {$wave} { append b { -w} }
	append b { -p $circuit << [$t get 0.0 end] 2>@ stderr}
	
	# Run backend
	set p [eval "exec $b"]; $c delete all
	foreach i [split $p "\n"] { catch {eval "$c create $i"} }
	$c create text 675 26 -anchor e -font {courier 18 bold} -text "$device" -fill black
	
	update
}

# Build models and inspect the fit
proc model {t} {
	global wm backend device type macro mparams
	
	set c $wm.canvas; set m $wm.mframe.macro.menu
	$c delete all; $m delete 0 100; set macro ""; set mparams ""
	
	$c create text 360 288 -anchor c -text "Fitting model parameters; please wait..." -fill black; update
	
	set p [exec $backend -v -$type -m << [$t get 0.0 end] 2>@ stderr]
	foreach i [split $p "\n"] { catch {eval "$m $i"} }
	
	render $wm.canvas $t
}


# Operation parameters
set f $wm.pframe
frame $f -borderwidth 1 -relief flat
label $f.l1 -text "Rated power: "
label $f.l2 -text "W    Working point: "
label $f.l3 -text "V, "
label $f.l4 -text "mA; load "
label $f.l5 -text "R"
label $f.l6 -text "V"

entry $f.pa -width 4 -justify right -textvariable Pa
entry $f.v0 -width 6 -justify right -textvariable V0
entry $f.i0 -width 6 -justify right -textvariable I0
entry $f.rl -width 6 -justify right -textvariable RL
checkbutton $f.wave -variable wave -text "AC signal"
entry $f.vac -width 6 -justify right

set m $f.sig.menu
menubutton $f.sig -menu $m -textvariable signal -width 5 -direction below -indicatoron no -borderwidth 0 -relief sunk
menu $m -tearoff 0
$m add command -label "input" -command "set signal input; $f.vac configure -textvariable Vin"
$m add command -label "output" -command "set signal output; $f.vac configure -textvariable Vout"
$m invoke 0

pack $f.l1 $f.pa $f.l2 $f.v0 $f.l3 $f.i0 $f.l4 $f.rl $f.l5 -side left -expand no -pady 4
pack $f.l6 $f.vac $f.sig $f.wave -side right -expand no -pady 4
pack $f -side top -fill x


# Plot canvas
set c $wm.canvas
canvas $c -width 720 -height 580 -background white -borderwidth 2 -relief groove
pack $c -side top -padx .5m -pady .5m


# Model selector
set f $wm.mframe; set m $f.macro.menu; set cm $f.circuit.menu
frame $f -borderwidth 0 -relief flat
menubutton $f.macro -menu $m -textvariable macro -width 7 -direction above -indicatoron yes -borderwidth 2 -relief groove
entry $f.param -width 80 -justify left -textvariable mparams -borderwidth 2 -relief groove
menubutton $f.circuit -menu $cm -textvariable circuit -width 2 -direction above -indicatoron yes -borderwidth 2 -relief groove

menu $m -tearoff 0

menu $cm -tearoff 0
$cm add command -label "Single Ended" -command { set circuit "SE" }
$cm add command -label "Cathode Follower" -command { set circuit "CF" }
$cm add command -label "Push-Pull" -command { set circuit "PP" }
$cm invoke 0

pack $f.macro $f.param $f.circuit -side left -expand 1 -pady 4
pack $f -side top -fill x


# Action buttons
set b $wm.buttons; frame $b
button $b.plot -text Redraw -command "render $c $t"
button $b.print -text Print -command "print $c"
button $b.code -text "See Spice Code >>" -command {
	Notebook:raise .n "Spice Code"
	spice_code $ws.text
}
button $b.dismiss -text Dismiss -command "destroy ."
pack $b.plot $b.print $b.code $b.dismiss -side left -expand 1
pack $b -side bottom -fill x -pady 2m



#################### Spice Model #######################################

# Run text through m4 preprocessor
proc m4 {h t} {
	global argv0
	
	set f [file join [file dirname $argv0] "$h.m4"]
	set fp [open $f r]; set ht [read $fp]; append ht $t; close $fp
	
	return [exec m4 << $ht 2>@ stderr]
}

# Inspect Spice code
proc spice_code {t} {
	global device type macro mparams
	
	set m "* $device macro model\n"
	append m ".subckt $device  "
	append m [lindex {{} {} {P K} {P G K}} $type]
	append m "\n    $macro\($mparams\)\n.ends $device\n"
	
	$t delete 0.0 end
	$t insert 0.0 $m
	$t insert end "\n\n[m4 models $m]"
	$t mark set insert 0.0
}


set t $ws.text; set s $ws.scroll
scrollbar $s -command "$t yview" -bd 1
text $t -bg white -relief groove -bd 2 -yscrollcommand "$s set" -setgrid 1 -width 100 -height 50

set b $ws.buttons; frame $b
button $b.dismiss -text Dismiss -command "destroy ."
pack $b.dismiss -side left -expand 1

pack $b -side bottom -fill x -pady 2m
pack $s -side right -fill y
pack $t -expand yes -fill both



#################### Main Entry Point ##################################

# Load data from a file with auto-dispatch according to extension
proc load_file {f ext} {
	global device wt wd wm ws
	
	if {$f == ""} {
		set f [tk_getOpenFile \
			-initialfile [expr {$device != "" ? "$device$ext" : ""}] \
			-defaultextension $ext]
		if {$f == ""} { return }
	}
	
	if {$ext == ""} { set ext [file extension $f] }
	
	if { [switch $ext {
		.crv - .dat { catch {open $f r} fp }
		default { catch {image create photo curves -file $f} }
	}] } {
		tk_messageBox -parent . -type ok \
			-icon warning \
			-title "file not found" \
			-message "Could not open file '$f'"
		return
	}
	
	set_device [file rootname [file tail $f]]
	
	switch $ext {
		.crv {
			Notebook:raise .n "Curve Tracer"
			load_markers $wt.canvas $fp
			if { [lsearch [image names] curves] < 0 } {
				$wt.buttons.capture invoke
			}
		}
		
		.dat {
			Notebook:raise .n "Device Data"
			load_data $wd.text $fp
		}
		
		default {
			Notebook:raise .n "Curve Tracer"
			load_image $wt.canvas curves
		}
	}
	
	catch {close $fp}
}

load_file [lindex $argv 0] ""
